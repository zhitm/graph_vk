
///
node.current_group = None
node.eaten_ids = {node.id}
///


groups - set<set<Node>>

def louvain:
	reset_groups()
	while True:
		mozhem = True
		while mozhem:
			mozhem = False
			for node in nodes:
				group_ok = max(groups, key = lambda group: find_dQ(node, group))
				possible_dQ = find_dQ(node, group_ok)
				if possible_dQ < 0:
					pass
				else:
					Q += possible_dQ
					move_to(node, group)
					mozhem = True

		g.merge_groups()
		g.reset_groups()
		continue


def merge_groups():#DONE
	for group in groups:
		merge_group(group)


def merge_group(group): #DONE
	if len(group) == 0:
		groups.discard(group)
		return None
	
	if len(group) == 1:
		return group
	
	node_0 = group.pop()
	
	for node in group:
		node.pop()
		node_0 = merge_nodes(node_0, node)
	group.add(node_0)
	
	return group
	

cnt = -1
def merge_nodes(node_1, node_2): #DONE
	new_node = Node(cnt)
	cnt -= 1
	for friend, mass in node_1.friends:
		new_node.friends.update({friend: mass})
		
	for friend, mass in node_2.friends:
		if friend not in new_node.friends.keys:
			new_node.friends.update({friend: mass})
		else:
			mass1 = new_node.friends.get(friend)
			new_node.friends.update({friend: mass + mass1})
	
	for friend in new_node.friends:
		mass = new_node.friends.get(friend)
		friend.friends.update({new_node: mass})
	
	new_node.eaten_ids =  node_1.eaten_ids + node_2.eaten_ids
	
	return new_node


def reset_groups: #DONE
	groups.clear()
	for node in g.nodes:
		node.current_group = set(node)
		groups.add(node.current_group)
		

def move_to(node, group): #DONE
	if len(node.current_group) == 1:
		groups.discard(node.current_group)
	node.current_group.discard(node)
	group.add(node)
	

	